{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "618592cd-a258-4a41-9fec-54f727d39142",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from scipy.signal import peak_widths\n",
    "from tqdm import tqdm\n",
    "from math import sqrt,exp\n",
    "import matplotlib\n",
    "from matplotlib import pyplot as plt\n",
    "from multiprocessing import Pool\n",
    "from itertools import product\n",
    "from itertools import combinations\n",
    "!pip install qutip\n",
    "from qutip import *\n",
    "from mpl_toolkits.axes_grid1.inset_locator import inset_axes\n",
    "from scipy.optimize import curve_fit\n",
    "from string import ascii_lowercase\n",
    "settings.num_cpus = 100\n",
    "font = {'size'   : 17}\n",
    "matplotlib.rc('font', **font)\n",
    "matplotlib.rcParams['text.usetex'] = True\n",
    "plt.rcParams[\"figure.figsize\"]= 10, 8\n",
    "plt.rcParams['figure.dpi'] = 90\n",
    "matplotlib.rcParams['lines.linewidth'] = 2\n",
    "plt.rcParams['axes.grid'] = False\n",
    "plt.rcParams['axes.grid.which'] = \"both\"\n",
    "props = dict(boxstyle='round', alpha=0.1)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f095eb72-5496-4e39-9313-61a1edecb394",
   "metadata": {},
   "source": [
    "### Creating Hamiltonian manually"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "258a8483-8a96-4157-ad78-9cbc371a27f4",
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_basis(Ek_0):\n",
    "    sing_basis = ['0u', '0d']\n",
    "    for i in range(1, len(Ek_0)+1):\n",
    "        sing_basis +=  [str(i)+'u', str(i)+'d']\n",
    "    basis = []\n",
    "    for i in range(2*len(Ek_0)+3):\n",
    "        basis += combinations(sing_basis, i)\n",
    "    return basis\n",
    "\n",
    "    \n",
    "    \n",
    "def diag(Ek_0, V, U):\n",
    "    basis = get_basis(Ek_0)\n",
    "    H = np.zeros([len(basis)]*2)\n",
    "    for i, state in enumerate(basis):\n",
    "        if ('0u' in state and '0d' in state) or ('0u' not in state and '0d' not in state):\n",
    "            H[i][i] += U/4\n",
    "        else:\n",
    "            H[i][i] -= U/4\n",
    "        for k in range(1, len(Ek_0)+1):\n",
    "            if str(k)+'u' not in state and str(k)+'d' not in state:\n",
    "                H[i][i] -= Ek_0[k-1]\n",
    "            elif str(k)+'u' in state and str(k)+'d' in state:\n",
    "                H[i][i] += Ek_0[k-1]\n",
    "    return H\n",
    "\n",
    "\n",
    "def off_diag(Ek_0, V, U):\n",
    "    basis = get_basis(Ek_0)\n",
    "    H = np.zeros([len(basis)]*2)\n",
    "    for k in range(1, len(Ek_0)+1):\n",
    "        for (i, si), (j, sj) in product(enumerate(basis), enumerate(basis)):\n",
    "            si = list(si)\n",
    "            sj = list(sj)\n",
    "            if i==j or si == () or sj == ():\n",
    "                continue\n",
    "            if set(si + [str(k)+'u']) == set(sj + ['0u']) or set(sj + [str(k)+'u']) == set(si + ['0u']):\n",
    "                H[i][j] = V\n",
    "            if set(si + [str(k)+'d']) == set(sj + ['0d']) or set(sj + [str(k)+'d']) == set(si + ['0d']):\n",
    "                H[i][j] = V\n",
    "    return H\n",
    "        \n",
    "    \n",
    "def get_nd(Ek_0):\n",
    "    basis = get_basis(Ek_0)\n",
    "    nd_up = np.zeros([len(basis)]*2)\n",
    "    nd_dn = np.zeros([len(basis)]*2)\n",
    "    for i, state in enumerate(basis):\n",
    "        if '0u' in state:\n",
    "            nd_up [i][i] = 1\n",
    "        if '0d' in state:\n",
    "            nd_dn [i][i] = 1\n",
    "    return nd_up, nd_dn"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ed18703a-e590-4f13-bd1c-f6d186c83a9f",
   "metadata": {},
   "source": [
    "### Creating Hamiltonian using Qutip"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fb8c0cfa-0593-4ed9-92b2-b461f538c70b",
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_ham(Ek_0, V, ed, U):\n",
    "    H_d = 0\n",
    "    H_k = 0\n",
    "    H_v = 0\n",
    "    dim = len(Ek_0)\n",
    "    numop = create(2)*destroy(2)\n",
    "    cop = destroy(2)\n",
    "    H_d += ed*tensor([numop, identity(2)] + [identity(2)]*2*dim)\n",
    "    H_d += ed*tensor([identity(2), numop] + [identity(2)]*2*dim)\n",
    "    H_d += U*tensor([numop, numop] + [identity(2)]*2*dim)\n",
    "    for i in range(dim):\n",
    "        rem = (dim - i - 1)\n",
    "        H_k += Ek_0[i]*(tensor([identity(2)]*2 + [identity(2)]*2*i + [numop, identity(2)] + [identity(2)]*2*rem))\n",
    "        H_k += Ek_0[i]*(tensor([identity(2)]*2 + [identity(2)]*2*i + [identity(2), numop] + [identity(2)]*2*rem))\n",
    "        H_v += V * tensor([cop.dag(), identity(2)] + [identity(2)]*2*i + [cop, identity(2)] + [identity(2)]*2*rem)\n",
    "        H_v += V * tensor([identity(2), cop.dag()] + [identity(2)]*2*i + [identity(2), cop] + [identity(2)]*2*rem)\n",
    "    return H_d + H_k + H_v + H_v.dag()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d461d8c8-1796-4e98-95ba-35ac05bdf397",
   "metadata": {},
   "source": [
    "### $T=0$ Spectral function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a225b063-f5d1-46f3-b8da-895e2b988872",
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "def get_rho_X(args):\n",
    "    nfactor = 1\n",
    "    wfactor = 1\n",
    "    (En, Xn), Xgs, Egs, Z, hfactor, flag = args\n",
    "#     eta = (4*t + np.sqrt(abs(w_range))*wfactor)/nfactor\n",
    "    c0_up = tensor([identity(2), destroy(2)] + [identity(2)]*(len(Xgs.dims[0])-2))\n",
    "    C1 = Xgs.dag()*c0_up*Xn\n",
    "    C1_sq = np.real((C1*C1.dag())[0][0][0])\n",
    "    C2 = Xn.dag()*c0_up*Xgs\n",
    "    C2_sq = np.real((C2*C2.dag())[0][0][0])\n",
    "    eta = 4*t*(1 + 2.5*abs(En - Egs))\n",
    "    x1 = w_range + Egs - En\n",
    "    x2 = w_range + En - Egs\n",
    "    if flag == True:\n",
    "        return En - Egs, (C1_sq * np.exp(-(x1/eta)**2)/(eta*sqrt(np.pi)) + C2_sq * np.exp(-(x2/eta)**2)/(eta*sqrt(np.pi))) / Z\n",
    "    else:\n",
    "        if abs(En - Egs) < w_cut:\n",
    "            eta /= hfactor\n",
    "        return (C1_sq * np.exp(-(x1/eta)**2)/(eta*sqrt(np.pi)) + C2_sq * np.exp(-(x2/eta)**2)/(eta*sqrt(np.pi))) / Z\n",
    "\n",
    "    \n",
    "def get_nonint_ht(Ek_0, V, tqdm_flag=False):\n",
    "    U = 0\n",
    "    ed = -U/2\n",
    "    H = get_ham(Ek_0, V, ed, U)\n",
    "    H = 0.5 * (H + H.dag())\n",
    "    E, X = H.eigenstates()\n",
    "    X0 = X[np.where(E == min(E))]\n",
    "    A = sum(list(tqdm(Pool().map(get_rho_X, product(zip(E, X), X0, [E[0]], [len(X0)], [1], [False])), disable=tqdm_flag, total=len(X0)*len(E))))\n",
    "    A = 0.5*(A + np.flip(A))\n",
    "    return A[np.where(w_range == 0)]\n",
    "    \n",
    "    \n",
    "def get_correction_factor(E, X, h, tqdm_flag=False):\n",
    "    X0 = X[np.where(E == min(E))]\n",
    "    ar = np.zeros(2)\n",
    "    wt = np.zeros(2)\n",
    "    for pi, Ai in list(tqdm(Pool().map(get_rho_X, product(zip(E, X), X0, [E[0]], [len(X0)], [1], [True])), disable=tqdm_flag, total=len(X0)*len(E))):\n",
    "        if pi < w_cut:\n",
    "            wt[0] += Ai[np.where(w_range == 0)]\n",
    "            ar[0] += np.trapz(Ai, w_range)\n",
    "        else:\n",
    "            wt[1] += Ai[np.where(w_range == 0)]\n",
    "            ar[1] += np.trapz(Ai, w_range)\n",
    "    \n",
    "    hfactor = abs(h - wt[1])/wt[0]\n",
    "    return hfactor\n",
    "\n",
    "\n",
    "def get_FWHM(w_range, A):\n",
    "    w_half = w_range[(A <= max(A)) & (A>=max(A)/2)]\n",
    "    return (max(w_half) - min(w_half))\n",
    "    \n",
    "\n",
    "    \n",
    "def spec_func_U(U, Ek_0, V, non_int_ht, tqdm_flag=False):\n",
    "    ed = -U/2\n",
    "    H = get_ham(Ek_0, V, ed, U)\n",
    "    H = 0.5 * (H + H.dag())\n",
    "    E, X = H.eigenstates()\n",
    "    X0 = X[np.where(E == min(E))]\n",
    "    hfactor = get_correction_factor(E, X, non_int_ht, tqdm_flag=tqdm_flag)\n",
    "    A = sum(list(tqdm(Pool().map(get_rho_X, product(zip(E, X), X0, [E[0]], [len(X0)], [hfactor], [False])), disable=tqdm_flag, total=len(X0)*len(E))))\n",
    "    A = 0.5*(A + np.flip(A))\n",
    "    return A\n",
    "\n",
    "\n",
    "def create_axes(len_U):\n",
    "    fig1, ax1 = plt.subplots(len_U, figsize=(15,9*len_U))\n",
    "    ax1_in = []\n",
    "    for i, ax in enumerate(ax1):\n",
    "        ax.set_xlabel(r\"$\\omega/\\Delta$\")\n",
    "        ax.set_ylabel(r\"$A_d(\\omega)$\")\n",
    "        ax.set_title(r\"$U/\\Delta={}$\".format(np.round(U_range[i]/delta),2))\n",
    "        ax1_in.append([inset_axes(ax, width=\"40%\", height=\"50%\", loc=2), inset_axes(ax, width=\"40%\", height=\"50%\", loc=1)])\n",
    "        ax1_in[-1][0].axes.get_yaxis().set_visible(False)\n",
    "        ax1_in[-1][1].axes.get_yaxis().set_visible(False)\n",
    "    \n",
    "    fig2, ax2 = plt.subplots(figsize=(15,10))\n",
    "    ax2.set_xlabel(r\"$\\omega/\\Delta$\")\n",
    "    ax2.set_ylabel(r\"$A_d(\\omega)$\")\n",
    "    ax2_in = inset_axes(ax2, width=\"40%\", height=\"40%\", loc=2)\n",
    "    ax2_in.axes.get_yaxis().set_visible(False)\n",
    "    return fig1, ax1, ax1_in, fig2, ax2, ax2_in\n",
    "\n",
    "\n",
    "def get_wrange(w_end, len_w, p=1):\n",
    "    w_half = np.linspace(0, w_end, len_w)**p/w_end**(p-1)\n",
    "    w_range = np.unique(np.concatenate([-w_half, w_half]))\n",
    "    return w_range"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "500574ee-b886-4403-b1b4-7eecd28a6eca",
   "metadata": {},
   "outputs": [],
   "source": [
    "V = 0.1\n",
    "t = 0.05\n",
    "# delta = np.pi*V**2/(2*t)\n",
    "Nk = 4\n",
    "a = 1\n",
    "k_bath = 2*np.pi*np.arange(0, Nk)/(a*Nk)\n",
    "Ek_0 = -2*t*np.cos(k_bath*a)\n",
    "\n",
    "w_range = get_wrange(5, 10000, p=1)\n",
    "w_cut = 10**(-4)\n",
    "\n",
    "non_int_ht = get_nonint_ht(Ek_0, V)\n",
    "delta = float(1/(np.pi * non_int_ht))\n",
    "\n",
    "U_range = [0, 0.9, 1.3, 2, 2.5, 3, 4]\n",
    "# U_range = [0, 4]\n",
    "\n",
    "fig1, ax1, ax1_in, fig2, ax2, ax2_in = create_axes(len(U_range))\n",
    "\n",
    "for i, (U, ax) in enumerate(zip(U_range, ax1)):\n",
    "    A = spec_func_U(U, Ek_0, V, non_int_ht)\n",
    "    maxA = max(A)\n",
    "    area = np.trapz(A, w_range)\n",
    "    fwhm = get_FWHM(w_range, A)\n",
    "    textstr = '\\n'.join((\n",
    "    r'Area=%.4f' % np.trapz(A, w_range),\n",
    "    r'Height=%.4f' % max(A),\n",
    "    r'FWHM=%.4f' % get_FWHM(w_range, A)))\n",
    "    prominent_range = np.where(A > 10**(-3))\n",
    "    ax.plot(w_range[prominent_range]/delta, A[prominent_range])\n",
    "    ax1_in[i][0].plot(w_range[np.where(abs(w_range/delta) < 1/(1+U))]/delta, A[np.where(abs(w_range/delta) < 1/(1+U))])\n",
    "    ax1_in[i][1].plot(w_range[np.where(abs(w_range/delta) < 0.5/(1+U))]/delta, A[np.where(abs(w_range/delta) < 0.5/(1+U))])\n",
    "    ax.text(0.05, 0.2, textstr, transform = ax.transAxes, size=17, bbox=props, horizontalalignment=\"left\", fontfamily=\"monospaced\")\n",
    "    ax2.plot(w_range/delta, A, label=r\"$U/\\Delta={}$\".format(round(U/delta,2)))\n",
    "    if U == U_range[-1]:\n",
    "        ax2_in.plot(w_range[np.where(abs(w_range/delta) < 0.5/(1+U))]/delta, A[np.where(abs(w_range/delta) < 0.5/(1+U))])\n",
    "\n",
    "    \n",
    "ax2.legend()\n",
    "fig1.savefig(\"siam_specfunc_separate.pdf\", bbox_inches='tight')\n",
    "fig2.savefig(\"siam_specfunc_all.pdf\", bbox_inches='tight')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "65221d96-377b-46e5-9bff-70c3a0094d8b",
   "metadata": {},
   "outputs": [],
   "source": [
    "def fit_func(x, A, B, C):\n",
    "    return (A + B*x)*np.exp(-C*x)\n",
    "\n",
    "\n",
    "def fit_func_hrk(x, A, B, C, D, E, F):\n",
    "    return x*delta*(A + x**B + np.sin(C+D*x))*np.exp(-E*x**F)\n",
    "\n",
    "\n",
    "def plot_fit(x, y1, y2, xl=r\"$U/\\Delta$\", yl=r\"FWHM\", l=\"\", text=\"\", log=False, save=False):\n",
    "    plt.scatter(x, y1, marker=\".\", color='r', label=\"data\")\n",
    "    plt.plot(x, y2, label=l)\n",
    "    ax = plt.gca()\n",
    "    plt.text(0.05, 0.2, text, transform = ax.transAxes, size=17, bbox=props, horizontalalignment=\"left\", fontfamily=\"monospaced\")\n",
    "    if log == True:\n",
    "        plt.yscale(\"log\")\n",
    "    plt.xlabel(xl)\n",
    "    plt.ylabel(yl)\n",
    "    plt.legend()\n",
    "    if save != False:\n",
    "        plt.savefig(str(save), bbox_inches='tight')\n",
    "    plt.show()\n",
    "\n",
    "    \n",
    "V = 0.1\n",
    "t = 0.05\n",
    "Nk = 4\n",
    "a = 1\n",
    "k_bath = 2*np.pi*np.arange(0, Nk)/(a*Nk)\n",
    "Ek_0 = -2*t*np.cos(k_bath*a)\n",
    "\n",
    "w_range = get_wrange(3, 1000, p=4)\n",
    "w_cut = 10**(-4)\n",
    "non_int_ht = get_nonint_ht(Ek_0, V, tqdm_flag=True)\n",
    "delta = float(1/(np.pi * non_int_ht))\n",
    "\n",
    "U_range = np.arange(0, 5.05, 0.05)\n",
    "# fwhm_arr = [get_FWHM(w_range, spec_func_U(U, Ek_0, V, non_int_ht, tqdm_flag=True)) for U in tqdm(U_range)]\n",
    "args = curve_fit(fit_func, U_range, fwhm_arr, maxfev=10000)[0]\n",
    "print(*args)\n",
    "names = ascii_lowercase[:len(args)]\n",
    "textstr = '\\n'.join(['%s = %.4f' % (name,arg) for name,arg in zip(names,args)])\n",
    "fit_arr = [fit_func(U, *args) for U in U_range]\n",
    "plot_fit(U_range, fwhm_arr, fit_arr, xl=r\"$U/\\Delta$\", yl=r\"FWHM\", l=r\"Fit against $(a + bU)\\exp(-cU)$\", text=textstr, log=False, save=\"width_vs_U_simple_fit.pdf\")\n",
    "plot_fit(U_range, fwhm_arr, fit_arr, xl=r\"$U/\\Delta$\", yl=r\"FWHM\", l=r\"Fit against $(a + bU)\\exp(-cU)$\", text=textstr, log=True, save=\"width_vs_U_simple_fit_log.pdf\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9d532934-6b2d-4c96-8a0e-abd9cca43f78",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
